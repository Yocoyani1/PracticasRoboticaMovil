---
layout: page
title: Práctica 2.
permalink: /practica2/
---

## Objetivo
Durante el desarrollo de la práctica el alumno implementará un algoritmo para manipular y trasladar discos a distintos sitios dentro del simulador VexCode VR, con el fin de reforzar los conocimientos adquiridos en la práctica anterior.

## Playground
!["Disk Mover"](https://i.imgur.com/tZMEcZ1.jpg "Disk Mover")

## Desarrollo

### Colacción en columnas.

Para empezar con nuestro algoritmo crearemos una función que por medio de las coordenadas de nuestro robot y de la ubicación de los cuadrados rojos podamos colocarnos en alguna de las líneas que contienen discos, para ello realizaremos los siguientes pasos:

- Lo primero que haremos será crear una función que se llame *IrA()*, la cual recibirá como parámetros los valores en coordenadas *x* y *y* a la que deberá dirigirse el robot .

~~~
def IrA(xDeseada, yDeseada):

def when_started1():

vr_thread(when_started1())
~~~

- El algoritmo empezará tratando de llevar al robot a la posición deseada sobre el eje *y*. Para ello preguntaremos si la posición de nuestro robot es diferente a la deseada en el eje *y*, si llegase a ser la misma no se deberá llevar a cabo ninguna acción.

~~~
def IrA(xDeseada, yDeseada):
    if not (location.position(Y, MM) - yDeseada == 0):
~~~

- Posteriormente deberemos orientar el robot hacia arriba o hacia abajo dependiendo de la ubicación del punto al que deseemos llegar, por ello indicaremos que si la coordenada de la posición a la que estamos es mayor que la posción a la cual queremos el robot gire hasta estar de manera vertical hacia abajo y en caso contrario gire hasta permanecer vertical hacia arriba. Además por la lógica del algoritmo siempre se deberá colocar el robot en hacia arriba antes de moverse:

~~~
if location.position(Y, MM) > yDeseada:
    if 405 > location.position_angle(DEGREES) and location.position_angle(DEGREES) > 315 or -45 < location.position_angle(DEGREES) or location.position_angle(DEGREES) < 45:
        drivetrain.turn_for(RIGHT, 180, DEGREES)           
    drivetrain.drive_for(FORWARD, location.position(Y, MM) - yDeseada, MM)
    drivetrain.turn_for(RIGHT, 180, DEGREES)
else:
    if location.position_angle(DEGREES) > 135 and location.position_angle(DEGREES) < 225:
        drivetrain.turn_for(RIGHT, 180, DEGREES)
    drivetrain.drive_for(FORWARD, yDeseada - location.position(Y, MM), MM)
~~~

- Una vez realizado este procedimiento solo se tendrá que repetir el proceso con el eje *x*, cambiando la orientación de los ángulos.

~~~
if not (location.position(X, MM) - xDeseada == 0):
    if location.position(X, MM) > xDeseada:
        if location.position_angle(DEGREES) > 135 and location.position_angle(DEGREES) < 225:
            drivetrain.turn_for(RIGHT, 90, DEGREES)
        else:
            if 405 > location.position_angle(DEGREES) and location.position_angle(DEGREES) > 315 or -45 < location.position_angle(DEGREES) or location.position_angle(DEGREES) < 45:
                drivetrain.turn_for(LEFT, 90, DEGREES)
            drivetrain.drive_for(FORWARD, location.position(X, MM) - xDeseada, MM)
    else:
        if 405 > location.position_angle(DEGREES) and location.position_angle(DEGREES) > 315 or -45 < location.position_angle(DEGREES) or location.position_angle(DEGREES) < 45:
            drivetrain.turn_for(RIGHT, 90, DEGREES)
        else:
            if location.position_angle(DEGREES) > 135 and location.position_angle(DEGREES) < 225:
                drivetrain.turn_for(LEFT, 90, DEGREES)
        drivetrain.drive_for(FORWARD, xDeseada - location.position(X, MM), MM)
~~~

- Con ello nuestro algoritmo estaría completo, sin embargo, mencionamos el algoritmo siempre se debe empezar hacia arriba el movimiento, por lo que agregamos el siguiente código:

~~~
if location.position_angle(DEGREES) > 45 and 135 > location.position_angle(DEGREES):
        drivetrain.turn_for(LEFT, 90, DEGREES)
    else:
        if location.position_angle(DEGREES) > 135 and 225 > location.position_angle(DEGREES):
            drivetrain.turn_for(RIGHT, 180, DEGREES)
        else:
            if location.position_angle(DEGREES) > 225 and 315 > location.position_angle(DEGREES):
                drivetrain.turn_for(RIGHT, 90, DEGREES)
~~~



## Código completo en:
[https://github.com/Yocoyani1/PracticasRoboticaMovil/tree/gh-pages/code](https://github.com/Yocoyani1/PracticasRoboticaMovil/tree/gh-pages/code)
