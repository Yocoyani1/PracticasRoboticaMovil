---
layout: page
title: Práctica 3.
permalink: /practica3/
---

## Objetivo
El alumno aprenderá a implementar doa algorimos de búsqueda para la resolución de un laberinto.

## Playground
![Dynamic Wall Maze](https://i.imgur.com/fbFXhdO.jpg "Dynamic Wall Maze")

## Desarrollo

### Algoritmo Derecho

El algoritmo derecho es un algoritmo de búsqueda altamente utilizado por su facilidad de implementación, además de que no requiere que se conozca la ubicación final de la meta, sin embargo como contra tiene el que explorará varios caminos que pueden conducirlo erroneamente, por lo que el tiempo de resolución puede llegar a ser elevado

Para el algoritmo derecho lo que debemos tener en mente es que siempre debemos de explorar los caminos que se presenten a al lado derecho del robot, no importando que el robot no se haya topado con alguna pared. Además cuando llegue a un camino sin salida este deberá dar un giro de 180° y seguir con la búsqueda de una salida por la derecha.

- Crearemos una función que contendra al algoritmo llamada *AlgoritmoDerecho()*. En ella como primer paso pondremos una condición de llegada, que definirá el final del la ejecución del algoritmo; como vemos, la meta es de color rojo por lo que el robot se detendrá cuando detecte dicho color.

~~~
def AlgoritmoDerecho():
    while not down_eye.detect(RED):
~~~

- Una vez definida la condición de llegada lo único que debemos de hacer es preguntar si tiene posibilidad el robot para avanzar,, o sea si no hay un obstaculo como una pared que evite su paso. En caso de ser afirmativo avanzaremos y giraremos a la derecha para que en el siguiente ciclo veamos si hay posibilidad de avanzar en esa dirección; en el caso negativo giraremos a la izquierda hasta encontrar un camino o regresar por donde llegamos.

~~~
if distance.get_distance(MM) > 100:
    drivetrain.drive_for(FORWARD, 250, MM)
    drivetrain.turn_for(RIGHT, 90, DEGREES)
else:
    drivetrain.turn_for(LEFT, 90, DEGREES)
wait(5, MSEC)
~~~

Estos serían los pasos básicos del algoritmo, sin embargo, te darás cuenta que en algunos mapas llega a salirse de la pista, existen vasrias maneras de corregir ese error, sin embargo el más sencillo y general es el agregar un giro inicial a la derecha, para que desde el principio de la codificación verifique la posiblidad de ir por el lado derecho.

~~~
def AlgoritmoDerecho():
    drivetrain.turn_for(RIGHT, 90, DEGREES)
    while not down_eye.detect(RED):
~~~

Con ello veremos como resuelve nuestro robot el laberinto que pongamos.

![](https://i.imgur.com/iQtq1Xa.jpg "Ejemplo A.Derecho")
![](https://i.imgur.com/bQA1PEz.jpg "Ejemplo A.Derecho")

### Algoritmo de búsqueda por evaluación

A diferencia del algoritmo anterior para poder implentar una evaluación del movimiento qu tiene que realizar el robot debemos de conocer la ubicación final de nuestra meta, y con base en ello podremos evaluar que movimiento es el mejor.

- Como primer paso crearemos una función para implementar este algoritmo, e igual que en el caso anterior lo primero que haremos será colocar la condición de finalización:
~~~
def AlgoritmoDerecho():
    while not down_eye.detect(RED):
~~~



## Código completo en:
[https://github.com/Yocoyani1/PracticasRoboticaMovil/tree/gh-pages/code](https://github.com/Yocoyani1/PracticasRoboticaMovil/tree/gh-pages/code)