{"mode":"Text","textContent":"def calcularDistancias(direccion):\n    \n    distanciaFinalX = -120\n    distanciaFinalY = 850\n    \n    if direccion == 0:\n        distanciaInicialX = location.position(X, MM) + 250\n        distanciaInicialY = location.position(Y, MM)\n    elif direccion == 1:\n        distanciaInicialX = location.position(X, MM)\n        distanciaInicialY = location.position(Y, MM) + 250\n    elif direccion == 2:\n        distanciaInicialX = location.position(X, MM) - 250\n        distanciaInicialY = location.position(Y, MM)\n    \n    elif direccion == 3:\n        distanciaInicialX = location.position(X, MM) \n        distanciaInicialY = location.position(Y, MM) - 250\n    \n    distancia = ((distanciaFinalX-distanciaInicialX)**2 + (distanciaFinalY-distanciaInicialY)**2)**(1/2)\n\n    return distancia\n\ndef verificarPaso():\n\ndef AlgoritmoPorEvaluacion():\n    movimientos = []\n    distanciasFuturas = []\n    ultimoMovimiento = -1\n    while not down_eye.detect(RED):\n        for i in range(4):\n            distanciasFuturas.append(calcularDistancia(i))\n        mejorCamino = 0\n        for distancia in distanciasFututas:\n            if distancia < distanciasFuturas[mejorCamino] and not movimientoAnterior(distanciasFuturas.index(distancia)):\n                if verificarPaso(distanciasFuturas.index(distancia)):\n                    mejorCamino = distanciasFuturas.index(distancia)\n        \n        if verificarPaso(mejorCamino):\n            avanzarRobot(mejorCamino)\n            movimientos.append(mejorCamino)\n        else:\n            ultimoMovimiento = movimientos.pop()\n            avanzarRobot(4)\n        wait(5,MSEC)\n\n\n\n        \ndef when_started1():\n    drivetrain.set_drive_velocity(100, PERCENT)\n    drivetrain.set_turn_velocity(100, PERCENT)\n    AlgoritmoPorEvaluacion\n\nvr_thread(when_started1())\n","textLanguage":"python","rconfig":[],"slot":0,"platform":"PG","sdkVersion":"","appVersion":"","fileFormat":"1.0.0","icon":"","playground":"DynamicWallMaze"}